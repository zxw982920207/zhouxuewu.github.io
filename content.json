[{"title":"Hello World","date":"2018-07-21T07:33:59.988Z","path":"2018/07/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Ethereum私有链的搭建和部分源码编译问题的汇总","date":"2018-04-12T16:00:00.000Z","path":"2018/04/13/Ethereum私有链的搭建及部分源码编译问题汇总/","text":"学习以太坊 准备1.安装curl,git 2.安装go配置环境变量 12345# go configexport GOPATH=$HOME/goexport GOBIN=$HOME/go/binexport GOROOT=/usr/local/goexport PATH=/usr/local/go/bin:$GOPATH/bin:$PATH 3.安装nodejs+npm 1.Ethereum环境安装12345sudo apt-get install software-properties-commonsudo add-apt-repository -y ppa:ethereum/ethereumsudo add-apt-repository -y ppa:ethereum/ethereum-devsudo apt-get updatesudo apt-get install ethereum 此时,安装的以太坊客户端版本号是最新稳定版.对于1.5.9-stable版本的geth,我们需要通过编译源码获得. 1234git clone https://github.com/ethereum/go-ethereumcd go-ethereumgit checkout v1.5.9 #切换版本make geth #编译 2.solc源码编译安装123sudo add-apt-repository ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install solc 此时,安装的solc也是最新版本.旧版本的solc需要通过编译源码的方式获得. 12345git clone https://github.com/ethereum/solidity.gitcd soliditygit checkout v0.4.10 #切换版本sudo ./scripts/install_deps.sh #安装依赖sudo ./scripts/build.sh #源码编译 Ps:在Ubuntu16.04本地环境下,源码编译成功.但在Ubuntu16.04服务器环境下,编译失败,寻因未果.报错信息如下: 1234-- Configuring incomplete, errors occurred!See also \"/home/ubuntu/solidity/build/CMakeFiles/CMakeOutput.log\".See also \"/home/ubuntu/solidity/build/CMakeFiles/CMakeError.log\".Failed to build 3.启动以太坊客户端1.创建账户 123geth account newgeth account newgeth account new #连续创建三个账户,密码123456 2.生成创世区块 编辑创世区块配置文件 123456789101112131415161718192021222324252627&#123; # ~/test-genesis.json \"nonce\": \"0x0000000000000042\", \"difficulty\": \"0x1\", \"alloc\": &#123; \"246d779602e185a53240a6cc5b01f74a17bd5deb\": &#123; #实际账户地址,需自定义 \"balance\": \"20000009800000000000000000000\" #每个账户余额初始值 &#125;, \"c0a07133e5dc82ab923bbe9506f3ea4479d2b797\": &#123; \"balance\": \"20000009800000000000000000000\" &#125;, \"b62b9d792e9825072f3d416569cc07e43a20c84f\": &#123; \"balance\": \"20000009800000000000000000000\" &#125; &#125;, \"config\": &#123; \"chainId\": 15, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;, \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"timestamp\": \"0x00\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"extraData\": \"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\", \"gasLimit\": \"0x2fefd8\"&#125; 生成创世区块 1geth --datadir \"~/.ethereum\" init blockchain/test-genesis.json 3.配置以太坊客户端启动脚本 保存账号密码到password文件,用于解锁账户 12345# 配置密码,每一个账户对应一行密码# ~/.ethereum/password123456123456123456 在以太坊中,出于安全机制,以太坊每隔一段时间就会锁定账户所以我们可以有两种方式解锁以太坊账户1.在启动脚本中读取密码文件解锁2.使用以下js交互命令 1web3.eth.personal.unlockAccount(fromAddress, passWord, 10000) #解锁持续时间10000ms 编写启动脚本 1234# ~/.ethereum/private_blockchain.shgeth --rpc --rpcaddr=\"0.0.0.0\" --rpccorsdomain=\"*\" --unlock '0,1,2' #解锁三个账户 --password ~/.ethereum/password #保存密码明文的文件 --nodiscover --maxpeers '5' --networkid '1234574' --datadir '~/.ethereum' console 启动以太坊客户端,进入JS交互式命令行 1bash private_blockchain.sh 4.智能合约的编译与部署 部署合约前的准备工作:通过Remix或趣链开发者平台编译智能合约获得ABI和BIN.account的balance大于0且已解锁. 定义bank_abi 1bank_abi=[&#123;constant:false,inputs:[&#123;name:'a',type:'uint256'&#125;],name:'multiply',outputs:[&#123;name:'d',type:'uint256'&#125;],type:'function'&#125;] #此处为实例,实际abi需自定义 创建合约 1bankContract = web3.eth.contract(bank_abi) 解锁账户 1personal.unlockAccount(eth.coinbase, '123456', 10000) #eth.coinbase是指定矿工的地址,默认是eth.accounts[0] 部署合约 1bank=bankContract.new(&#123;from:eth.coinbase,data:\"0x60606040523415600b57fe5b5b60788061001a6000396000f300606060405263ffffffff60e060020a600035041663c6888fa181146020575bfe5b3415602757fe5b60306004356042565b60408051918252519081900360200190f35b600781025b9190505600a165627a7a7230582007a6259ba3d57941abda2e261e9a67958a3eda78b779d9dd8d42518791fddd590029\"&#125;) #此处的二进制是智能合约编译后生成的BIN,需自定义 挖矿上链 部署合约的过程实际也是由创建合约的账户发送的一笔交易（即eth.coinbase账户）。需要挖矿进行确认。 12miner.start(1) #启动一个线程(貌似)miner.stop() #需手动停止挖矿 确认上链 1eth.getBlocks[1] #区块编号一般是已有区块的基础上加1 此时,如果usedGas参数大于0,表示挖矿成功. 5.webapp与以太坊平台的交互方式 未完待续 常用命令汇总geth命令: 123geth --datadir \"~/.ethereum\" init ./test-genesis.json #以test-genesis.json脚本初始化创世区块,设置datadirgeth account new #新建一个账户,需要输入两次密码geth account list #list所有的账户地址 js交互命令: 12345678910eth #列出所有的账户地址,区块数以及eth命令下的函数名称eth.coinbase #矿工地址,一般为第一个账户地址,即eth.accounts[0]eth.accounts[0] #第一个账户地址eth.getBlocks(0) #获取第一个区块信息eth.getBalance(eth.accounts[0]) #获取第一个账户的余额eth.getTransactionRecepit(xxx) #获取部署后的合约地址,参数为合约地址所在的区块中的Transaction字段admin.setSloc('/usr/local/bin/solc') #指定solc编译器的地址txpool.status #查看交易池信息,比如等待队列中交易的数量miner.start(1) #开启一个线程进行挖矿操作miner.stop() #需要手动停止挖矿 参考资料 ubuntu系统搭建以太坊私有链 以太坊合约简单部署和使用","tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://successli.cn/tags/blockchain/"}]},{"title":"Ethereum以太坊的学习与实践","date":"2018-04-05T16:00:00.000Z","path":"2018/04/06/Ethereum以太坊的学习与实践/","text":"学习以太坊 区块链区块链就是一个具有共享状态的密码性安全交易的单机(cryptographically secure transactional singleton machine with shared-state)。 “密码性安全(Cryptographically secure)”是指用一个很难被解开的复杂数学机制算法来保证数字货币生产的安全性。将它想象成类似于防火墙的这种。它们使得欺骗系统近乎是一个不可能的事情（比如：构造一笔假的交易，消除一笔交易等等）。 “交易的单机(Transactional singleton machine)”是指只有一个权威的机器实例为系统中产生的交易负责任。换句话说，只有一个全球真相是大家所相信的。 “具有共享状态(With shared-state)”是指在这台机器上存储的状态是共享的，对每个人都是开放的。 以太坊实现了区块链的这个范例。 以太坊 定义:以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。 实际上,以太坊，Ethereum是一个分布式的计算机，有许多的节点，其中的每一个节点，都会执行字节码（其实就是智能合约），然后把结果存在区块链上。由于整个网络是分布式的，且应用就是一个个的状态组成，存储了状态就有了服务；所以它就能永不停机，没有一个中心化的结点（没有任何一个节点说了算，去中心化的），任何第三方不能干预。 一些概念 以太坊的本质就是一个基于交易的状态机(transaction-based state machine)。在计算机科学中，一个状态机是指可以读取一系列的输入，然后根据这些输入，会转换成一个新的状态出来的东西。 根据以太坊的状态机，我们从创世纪状态(genesis state)开始。这差不多类似于一片空白的石板，在网络中还没有任何交易的产生状态。当交易被执行后，这个创世纪状态就会转变成最终状态。在任何时刻，这个最终状态都代表着以太坊当前的状态。 以太坊的状态有百万个交易。这些交易都被“组团”放到一个区块中。一个区块包含了一系列的交易，每个区块都与它的前一个区块链接起来。 为了让一个状态转换成下一个状态，交易必须是有效的。为了让一个交易被认为是有效的，它必须要经过一个验证过程，此过程也就是挖矿。挖矿就是一组节点（即电脑）用它们的计算资源来创建一个包含有效交易的区块出来。 任何在网络上宣称自己是矿工的节点都可以尝试创建和验证区块。世界各地的很多矿工都在同一时间创建和验证区块。每个矿工在提交一个区块到区块链上的时候都会提供一个数学机制的“证明”，这个证明就像一个保证：如果这个证明存在，那么这个区块一定是有效的。为了让一个区块添加到主链上，一个矿工必须要比其他矿工更快的提供出这个“证明”。通过矿工提供的一个数学机制的“证明”来证实每个区块的过程称之为工作量证明(proof of work)。 深入地了解一下以太坊系统主要组成部分： 账户(accounts) 状态(state) 损耗和费用(gas and fees) 交易(transactions) 区块(blocks) 交易执行(transaction execution) 挖矿(mining) 工作量证明(proof of work) 以太坊账户以太坊的全局“共享状态”是有很多小对象（账户）来组成的，这些账户可以通过消息传递来与对方进行交互。每个账户都有一个与之关联的状态(state)和一个20字节的地址(address)。在以太坊中一个地址是160位的标识符，用来识别账户。 以太坊有两种类型的账户： 外部账户（由私钥控制的） 合约账户（由合约代码控制）。 两种账户都可以发起交易，后者被动发送。 外部拥有账户与合约账户的比较 一个外部拥有账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部拥有账户或合约账户。在两个外部拥有账户之间传送的消息只是一个简单的价值转移。但是从外部拥有账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作。（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。 不像外部拥有账户，合约账户不可以自己发起一个交易。相反，合约账户只有在接收到一个交易之后(从一个外部拥有账户或另一个合约账户处)，为了响应此交易而触发一个交易。 因此，在以太坊上任何的动作，总是被外部拥有账户触发的交易所发动的。 账户状态 账户状态有四个组成部分，不论账户类型是什么，都存在这四个组成部分： nonce：如果账户是一个外部拥有账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号 balance： 此地址拥有Wei的数量。1Ether=10^18Wei storageRoot： Merkle Patricia树的根节点Hash值（我们后面在解释Merkle树）。Merkle树会将此账户存储内容的Hash值进行编码，默认是空值 codeHash：此账户EVM（以太坊虚拟机，后面细说）代码的hash值。对于合约账户，就是被Hash的代码并作为codeHash保存。对于外部拥有账户，codeHash域是一个空字符串的Hash值 gas和费用在以太坊中一个比较重要的概念就是费用(fees)，由以太坊网络上的交易而产生的每一次计算，都会产生费用—没有免费的午餐。这个费用是以”gas”来支付。Gas就是用来衡量在一个具体计算中要求的费用单位。gas price就是你愿意在每个gas上花费Ether的数量，以“gwei”进行衡量。“Wei”是Ether的最小单位，1Ether=10^18Wei，1gwei=1,000,000,000 Wei。对每个交易，发送者设置gas limit和gas price。gas limit和gas price就代表着发送者愿意为执行交易支付的Wei的最大值。 消息和交易最基本的概念，一个交易就是指被外部拥有账户生成的加密签名的一段指令，序列化之后提交给区块链。 有两种类型的交易：消息通信(message calls)和合约创建(contract creations)(也就是交易产生一个新的以太坊合约)。不管什么类型的交易，都包含： nonce：发送者发送交易数的计数 gasPrice：发送者愿意支付执行交易所需的每个gas的Wei数量 gasLimit：发送者愿意为执行交易支付gas数量的最大值。此值设置之后在任何计算完成之前就会被提前扣掉 to：接收者的地址。在合约创建交易中，合约账户的地址还没有存在，所以值先空着 value：从发送者转移到接收者Wei的数量。在合约创建交易中，value作为新建合约账户的开始余额 v,r,s：用于产生标识交易发送者的签名 init（只有在合约创建交易中存在）：用来初始化新合约账户的EVM代码片段。init值会执行一次，然后就会被丢弃。当init第一次执行的时候，它返回一个账户代码体，也就是永久与合约账户关联的一段代码。 data（可选域，只有在消息通信中存在）：消息通信中的输入数据(也就是参数)。例如，如果智能合约就是一个域名注册服务，那么调用合约可能就会期待输入参数：域名和IP地址 区块所有的交易都被组成一个”块”。一个区块链包含了一系列这样链在一起的区块。在以太坊中，一个区块包含： 区块头 关于包含在此区块中交易集的信息 与当前块的ommers相关的一系列其他区块头 ommers解释 “ommer”到底是什么？ ommer就是一个区块的父区块与当前区块父区块的父区块是相同的。让我们快速了解一下ommers是用来干嘛的，并且为什么一个区块需要为ommers包含区块头。由于以太坊的构造，它的区块生产时间（大概15秒左右）比其他的区块链例如Bitcoin（大概10分钟左右）要快很多。这使得交易的处理更快。但是，更短的区块生产时间的一个缺点就是：更多的竞争区块会被矿工发现。这些竞争区块同样也被称为“孤区块”（也就是被挖出来但是不会被添加到主链上的区块）。Ommers的目的就是为了帮助奖励矿工纳入这些孤区块。矿工包含的ommers必须是有效的，也就是ommers必须是往上数6代之内或更小范围内父区块的子区块。 一个孤区块在第6个子区块之后，这种陈旧的孤区块将不会再被引用（因为包含老旧的交易会使事情变得复杂一点）。Ommer区块会收到比全区块少一点的奖励。不管怎样，依然存在激励来让矿工们纳入孤区块并能从中获得一些报酬。 区块头 1234567891011121314151617181920212223&gt; eth.getBlock(1)&#123; difficulty: 131072, extraData: \"0xd783010509846765746887676f312e352e31856c696e7578\", gasLimit: 3144658, gasUsed: 1910026, hash: \"0xc0b29bc36695a0437fbc8886bf37f845582169062bc6d62885a5fe626f7e295e\", logsBloom: \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", miner: \"0x5a1d4c5249f27ef473a6ab3b715f03313fd1f560\", mixHash: \"0x591c1f3f5a0ded2059f1e587c160f9bf7a0d68d26d59becb30d6522877f2adfc\", nonce: \"0x4212740f3207045d\", number: 1, parentHash: \"0x33a09ce307ed33581a1a0e2f854de4e55d6a5be246a08408c76da9dd5959869a\", receiptsRoot: \"0x68c0e9f576c9d919b9246071b48e216bb664175e3449a41e97cdc9faa63af2be\", sha3Uncles: \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", size: 7601, stateRoot: \"0x162deb8236f6a1ac694e24fb88bd9c1665c90135b6535a6281a2f6ae43b19f19\", timestamp: 1523541484, totalDifficulty: 131073, transactions: [\"0x21db4aef57dab234ec12f864be40cd4e8a598262ffdb02a9e1d3b14b2a200b9a\"], transactionsRoot: \"0x7319b6173c48ecb69021575df2b8cc508c2fe1f3645cf63ad9f07125f35d4226\", uncles: []&#125; parentHash：父区块头的Hash值（这也是使得区块变成区块链的原因）ommerHash：当前区块ommers列表的Hash值beneficiary：接收挖此区块费用的账户地址stateRoot：状态树根节点的Hash值（回忆一下我们之前所说的保存在头中的状态树以及它使得轻客户端认证任何关于状态的事情都变得非常简单）transactionsRoot：包含此区块所有交易的Merkle树的根节点Hash值receiptsRoot：包含此区块所有交易收据的Merkle树的根节点Hash值logsBloom：由日志信息组成的一个Bloom过滤器 (一种数据结构)difficulty： 此区块的难度级别number：当前区块的计数（创世纪块的区块序号为0，对于每个后续区块，区块序号都增加1）gasLimit：每个区块的当前gas limitgasUsed： 此区块中交易所用的总gas量timestamp：此区块成立时的unix的时间戳extraData：与此区块相关的附加数据mixHash：一个Hash值，当与nonce组合时，证明此区块已经执行了足够的计算nonce：一个Hash值，当与mixHash组合时，证明此区块已经执行了足够的计算 交易收据 123456789101112131415&gt; eth.getTransactionReceipt(\"0x21db4aef57dab234ec12f864be40cd4e8a598262ffdb02a9e1d3b14b2a200b9a\")&#123; blockHash: \"0xc0b29bc36695a0437fbc8886bf37f845582169062bc6d62885a5fe626f7e295e\", blockNumber: 1, contractAddress: \"0xc94dbcd3480d6c2c92bd303382ed3c3a3308194a\", cumulativeGasUsed: 1910026, from: \"0x5a1d4c5249f27ef473a6ab3b715f03313fd1f560\", gasUsed: 1910026, logs: [], logsBloom: \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", root: \"0x8f0fb37f003cb64fcbde2adefd1adcf1d588833241fad6e14b9439d26c36bf05\", to: null, transactionHash: \"0x21db4aef57dab234ec12f864be40cd4e8a598262ffdb02a9e1d3b14b2a200b9a\", transactionIndex: 0&#125; 交易收据包含着日志信息的交易收据的根Hash值保存在头中。 就像你在商店买东西时收到的收据一样，以太坊为每笔交易都产生一个收据。像你期望的那样，每个收据包含关于交易的特定信息，这些信息为： 区块序号(blockNumber) 区块Hash值(blockHash) 交易Hash值(transactionHash) 当前交易使用了的gas(gasUsed) 在当前交易执行完之后当前块使用的累计gas(cumulativeGasUsed) 执行当前交易时创建的日志(logsBloom) 等等 难度调整 区块的难度是被用来在验证区块时加强一致性。创世纪区块的难度是131,072，有一个特殊的公式用来计算之后的每个块的难度。如果某个区块比前一个区块验证的更快，以太坊协议就会增加区块的难度。区块的难度影响nonce，它是在挖矿时必须要使用工作量证明算法计算出的一个Hash值。区块难度和nonce之间的关系用数学形式表达就是： 1n &lt;= (2^256/Hd) Hd代表的是难度。找到符合难度阈值的nonce唯一方法就是使用工作量证明算法来列举所有的可能性。找到解决方案预期时间与难度成正比—难度越高，找到nonce就越困难，因此验证一个区块也就越难，这又相应地增加了验证新块所需的时间。所以，通过调整区块难度，协议可以调整验证区块所需的时间。另一方面，如果验证时间变的越来越慢，协议就会降低难度。这样的话，验证时间自我调节以保持恒定的速率—平均每15s一个块。 以太坊的应用场景一般来讲，以太坊之上有三种应用。第一类是金融应用，为用户提供更强大的用他们的钱管理和参与合约的方法。包括子货币，金融衍生品，对冲合约，储蓄钱包，遗嘱，甚至一些种类的全面的雇佣合约。第二类是半金融应用，这里有钱的存在但也有很重的非金钱的方面，一个完美的例子是为解决计算问题而设的自我强制悬赏。最后，还有在线投票和去中心化治理这样的完全的非金融应用。 以太坊客户端P2P协议 以太坊客户端 P2P 协议是一个相当标准的加密货币协议,并且能够容易地为其它加密货币使用;仅有的改动是引入了由 YonatanSompolinsky 和 Aviv Zohar 在 2013 年 12 月首次引入的“幽灵“协议(“Greedy Heaviest Observed Subtree” (GHOST) protocol);该协议的引入动机和实现细节将在后面作详细介绍。以太坊客户端基本上是被动的;如果没有被触发,它自己做的仅有工作是调用网络守护进程维护连接及定期发送消息索要以当前区块为父区块的区块。然而,该客户端同时会更强大;与只存储与块链相关的有限数据的 bitcoind 不同,以太坊客户端将同时扮演一个功能完整的区块浏览器的后台的角色。 当客户端收到一个消息时,它将执行以下布骤: 哈希该数据,并且检查该数据与其哈希是否已经接收过,如果是,退出,否则将数据发送给数据分析器。 确认数据类型。如果该数据项是一个交易,如果交易合法则将其加入本地交易列表,加入当前区块并发布至网络。如果该数据项是一个消息,作出回应。如果该数据项是一个区块,转入步骤 3。 检查区块中的“父区块“参数是否已存储于数据库中。如果没有,退出。 检查该区块头以及其“叔区块列表”中所有区块头中的工作量证明是否合法,如有任意一个非法,退出。 检查“叔区块列表”中每一个区块的区块头以确定其是否以该区块的“祖父区块”为父区块。如有任何否,退出。注意叔区块头并不必须在数据库中;他们只需有共同的父区块并有合法的工作量证明。 检查区块中的时间戳是否最后至未来 15 分钟并且在其父区块的时间戳之后。检查该区块的难度与区块号码匹配。如任何检查失败,退出。 由该区块的父区块的状态开始,加上该区块中的每一笔合法交易。最后,加上矿工奖励。如果结果状态树的根哈希与区块头中的状态根不匹配,退出。如匹配,将该区块加入数据库并前进至下一步。 为新区块确定 TD(block) (“总难度”)。TD 由 TD(genesis_block) = 0 及 TD(B) = TD(B.parent) + sum(u.difficulty for u in B.uncles) + B.difficulty 递归定义。如新区块拥有比现区块更高的总难度,则新区块将成为“现区块“并进入下一步,否则,退出。 如果新区块被改动,向其中加入交易列表中的所有交易,废除交易列表中的所有变为不合法的交易,将该区块及这些交易向全网重新广播。 智能合约合约的创建回忆一下在以太坊中，有两种账户类型：合约账户和外部拥有账户。当我们说一个交易是“合约创建”，是指交易的目的是创建一个新的合约账户。为了创建一个新的合约账户，我们使用一个特殊的公式来声明新账户的地址。然后我们使用下面的方法来初始化一个账户： 设置nonce为0 如果发送者通过交易发送了一定量的Ether作为value，那么设置账户的余额为value 将存储设置为0 设置合约的codeHash为一个空字符串的Hash值 一旦我们完成了账户的初始化，使用交易发送过来的init code（查看”交易和消息”章节来复习一下init code），实际上就创造了一个账户。init code的执行过程是各种各样的。取决于合约的构造器，可能是更新账户的存储，也可能是创建另一个合约账户，或者发起另一个消息通信等等。当初始化合约的代码被执行之后，会使用gas。交易不允许使用的gas超过剩余gas。如果它使用的gas超过剩余gas，那么就会发生gas不足异常(OOG)并退出。如果一个交易由于gas不足异常而退出，那么状态会立刻恢复到交易前的一个点。发送者也不会获得在gas用完之前所花费的gas。不过，如果发送者随着交易发送了Ether，即使合约创建失败Ether也会被退回来。如果初始化代码成功的执行完成，最后合约创建的花费会被支付。这些是存储成本，与创建的合约代码大小成正比（再一次，没有免费的午餐）。如果没有足够的剩余gas来支付最后的花费，那么交易就会再次宣布gas不足异常并中断退出。如果所有的都正常进行没有任何异常出现，那么任何剩余的未使用gas都会被退回给原始的交易发送者，现在改变的状态才被允许永久保存。 消息通信消息通信的执行与合约创建比较类似，只不过有一点点区别。由于没有新账户被创建，所以消息通信的执行不包含任何的init code。不过，它可以包含输入数据，如果交易发送者提供了此数据的话。一旦执行，消息通信同样会有一个额外的组件来包含输出数据，如果后续执行需要此数据的话组件就会被使用。就像合约创建一样，如果消息通信执行退出是因为gas不足或交易无效（例如栈溢出，无效跳转目的地或无效指令），那么已使用的gas是不会被退回给原始触发者的。相反，所有剩余的未使用gas也会被消耗掉，并且状态会被立刻重置为余额转移之前的那个点。没有任何方法停止或恢复交易的执行而不让系统消耗你提供的所有gas，直到最新的以太坊更新。例如，假设你编写了一个合约，当调用者没有授权来执行这些交易的时候抛出一个错误。在以太坊的前一个版本中，剩余的gas也会被消耗掉，并且没有任何gas退回给发送者。但是拜占庭更新包括了一个新的“恢复”代码，允许合约停止执行并且恢复改变的状态而不消耗剩余的gas，此代码还拥有返回交易失败原因的能力。如果一个交易是由于恢复而退出，那么未使用的gas就会被退回给发送者。 参考 以太坊白皮书(中文) 以太坊（Ethereum）:下一代智能合约和去中心化应用平台 (转)Merkle Tree（默克尔树）算法解析 以太坊开发入门，完整入门篇 How does Ethereum work, anyway?","tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://successli.cn/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"http://successli.cn/tags/ethereum/"}]},{"title":"浅谈Java多线程","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/浅谈Java多线程/","text":"1.线程与进程 进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含多个线程。（进程是资源分配的最小单位） 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位） 2.线程的创建2.1 线程的两种创建方式 a.继承java.lang.Thread类 123456789101112131415161718192021package multiThread;/** * Created by succe on 2018/1/14. */public class Test01 &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); &#125;&#125;class MyThread extends Thread&#123; private static int num = 0; public MyThread()&#123; num++; &#125; @Override public void run() &#123; System.out.println(\"主动创建的第\"+num+\"个线程\"); &#125;&#125; 运行结果如下： 123主动创建的第1个线程Process finished with exit code 0 创建好了自己的线程类之后，就可以创建线程对象了，然后通过start()方法去启动线程。注意，不是调用run()方法启动线程，run()方法中只是定义需要执行的任务，如果调用run方法， 即相当于在主线程中执行run方法，跟普通的方法调用没有任何区别，此时并不会创建一个新的线程来执行定义的任务。 start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。 start()方法调用和 run()方法调用的区别： 12345678910111213141516171819202122232425package multiThread;/** * Created by succe on 2018/1/14. */public class Test03 &#123; public static void main(String[] args) &#123; System.out.println(\"主线程ID:\"+Thread.currentThread().getId()); MyThread03 thread1 = new MyThread03(\"thread1\"); thread1.start(); MyThread03 thread2 = new MyThread03(\"thread2\"); thread2.run(); &#125;&#125;class MyThread03 extends Thread &#123; private String name; public MyThread03(String name)&#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(\"name:\"+name+\" 子线程ID:\"+Thread.currentThread().getId()); &#125;&#125; 运行结果如下： 12345主线程ID:1name:thread2 子线程ID:1name:thread1 子线程ID:11Process finished with exit code 0 结论： 线程 Thread2()和主线程 ID相同，说明：通过 run()方法调用的线程不会创建新的线程，而是在主线程上直接运行 run()方法，和普通的方法没有区别 b.实现java.lang.Runable接口 123456789101112131415161718package multiThread;/** * Created by succe on 2018/1/14. */public class Test02 &#123; public static void main(String[] args) &#123; System.out.println(\"主线程ID：\"+Thread.currentThread().getId()); MyRunable myRunable = new MyRunable(); Thread thread = new Thread(myRunable); thread.start(); &#125;&#125;class MyRunable implements Runnable &#123; public void run() &#123; System.out.println(\"子线程ID：\"+Thread.currentThread().getId()); &#125;&#125; 运行结果如下： 1234主线程ID：1子线程ID：11Process finished with exit code 0 Runnable的中文意思是“任务”，顾名思义，通过实现Runnable接口，我们定义了一个子任务，然后将子任务交由Thread去执行。注意，这种方式必须将Runnable作为Thread类的参数，然后通过Thread的start方法 来创建一个新线程来执行该子任务。 事实上，查看Thread类的实现源代码会发现Thread类是实现了Runnable接口的。 在Java中，这2种方式都可以用来创建线程去执行子任务，具体选择哪一种方式要看自己的需求。直接继承Thread类的话，可能比实现Runnable接口看起来更加简洁，但是由于Java只允许单继承，所以如果自定义类需 要继承其他类，则只能选择实现Runnable接口。 2.2 Thread与Runnable的区别实现Runable接口比继承Thread类所具有的优势： a) 适合多个相同程序代码的线程去处理同一个资源 b) 可以避免Java中单继承的限制 c) 代码可以被多个线程共享，而代码的数据独立 d) 线程池不接受继承Thread的线程类 注：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。 在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实习在就是在操作系统中启动了一个进程。 3.线程对象常用函数12345678910111213141516171)public void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法2)public void run() 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则， 该方法不执行任何操作并返回3)public final void setName(String name) 改变线程名称，使之与参数 name 相同4)public final void setPriority(int priority) 更改线程的优先级5)public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程6)public final void join(long millisec) 等待该线程终止的时间最长为 millis 毫秒7)public void interrupt() 中断线程8)public final boolean isAlive() 测试线程是否处于活动状态 3.1 wait/notify/notifyAll 这是一组 Object 类的方法 注意：这三个方法都必须在同步的范围内调用 wait 1234567891011121314151617181920wait有三种方式的调用wait()必要要由 notify 或者 notifyAll 来唤醒wait(long timeout)在指定时间内，如果没有notify或notifAll方法的唤醒，也会自动唤醒。wait(long timeout,long nanos)本质上还是调用一个参数的方法public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout);&#125; notify/notifyAll notify只能唤醒一个处于wait的线程 notifyAll可以唤醒全部处于wait的线程 3.2 sleep/yield/join 这是一组Thread类的方法 sleep 让当前线程暂停指定时间，只是让出CPU的使用权，并不释放锁。 yield 暂停当前线程的执行，也就是当前CPU的使用权，让其他线程有机会执行，不能指定时间。会让当前线程从运行状态转变为就绪状态。 join 等待调用 join 方法的线程执行结束，才执行后面的代码，其调用一定要在 start 方法之后。使用场景：当父线程需要等待子线程执行结束才执行后面内容或者需要某个子线程的执行结果会用到 join 方法。 3.3 volatile关键字​ java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。 原理： 多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。 作用： 内存可见性（多线程操作的时候，一个线程修改了一个变量的值 ，其他线程能立即看到修改后的值） 防止重排序（即程序的执行顺序按照代码的顺序执行，处理器为了提高代码的执行效率可能会对代码进行重排序） 3.4 synchronized关键字 作用：确保线程互斥的访问同步代码 使用： synchronized单独使用 代码块 12345678public class Thread1 implements Runnable &#123; Object lock; public void run() &#123; synchronized(lock)&#123; ..do something &#125; &#125;&#125; 同一时间，只有一个线程可以使用lock实例。 直接用于方法 12345public class Thread1 implements Runnable &#123; public synchronized void run() &#123; ..do something &#125;&#125; 同一时间，只有一个线程可以调用run()方法。 synchronized,wait,notify结合使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//synchronized, wait, notify结合:典型场景生产者消费者问题/** * 生产者生产出来的产品交给店员 */ public synchronized void produce() &#123; if(this.product &gt;= MAX_PRODUCT) &#123; try &#123; wait(); System.out.println(\"产品已满,请稍候再生产\"); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; this.product++; System.out.println(\"生产者生产第\" + this.product + \"个产品.\"); notifyAll(); //通知等待区的消费者可以取出产品了 &#125; /** * 消费者从店员取产品 */ public synchronized void consume() &#123; if(this.product &lt;= MIN_PRODUCT) &#123; try &#123; wait(); System.out.println(\"缺货,稍候再取\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; System.out.println(\"消费者取走了第\" + this.product + \"个产品.\"); this.product--; notifyAll(); //通知等待去的生产者可以生产产品了 &#125; 4.线程状态转换 线程的优先级： 1234567891011121314/** * The minimum priority that a thread can have. */public final static int MIN_PRIORITY = 1;/** * The default priority that is assigned to a thread. */public final static int NORM_PRIORITY = 5;/** * The maximum priority that a thread can have. */public final static int MAX_PRIORITY = 10; 每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 1、Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。 线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。 JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。 2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。 3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。 4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。 5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。 5.线程的生命周期 线程的生命周期 线程在一个动态的生命周期中，会有不同的状态： 创建（new）: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。就绪（runnable）: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。运行（running）: 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。阻塞（blocked）: 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 终止（dead）: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 6.遇到的问题和解决方法 遇到的问题 在创建线程的过程中，实现了一段代码： 1234567891011121314151617181920212223/** * Created by succe on 2018/1/14. */public class Test01 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; MyThread01 thread01 = new MyThread01(); thread01.start(); &#125; &#125;&#125;class MyThread01 extends Thread&#123; private static int num = 0; public MyThread01()&#123; num++; &#125; @Override public void run() &#123; System.out.println(\"主动创建的第\"+num+\"个线程\"); &#125;&#125; 输出结果： 12345678主动创建的第100个线程主动创建的第100个线程主动创建的第100个线程主动创建的第100个线程主动创建的第100个线程......Process finished with exit code 0 为什么最后输出的全部都是100呢？ 期望输出的结果：1,2,3,4,5…… 原因：main线程执行过快，main线程执行结束时，num累加到了 100，子线程还处于runnable就绪状态。 解决办法 第一种解决方法：调用Thread.sleep()方法。 12345678910111213141516171819202122232425262728/** * Created by succe on 2018/1/14. */public class Test01 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; MyThread01 thread01 = new MyThread01(); thread01.start(); try &#123; Thread.sleep(1000);//解决 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class MyThread01 extends Thread&#123; private static int num = 0; public MyThread01()&#123; num++; &#125; @Override public void run() &#123; System.out.println(\"主动创建的第\"+num+\"个线程\"); &#125;&#125; Thread.sleep()方法可以让main线程暂定执行一小段时间。 第二种解决方法：调用子线程的join()方法。 12345678910111213141516171819202122232425262728/** * Created by succe on 2018/1/14. */public class Test01 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; MyThread01 thread01 = new MyThread01(); thread01.start(); try &#123; thread01.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class MyThread01 extends Thread&#123; private static int num = 0; public MyThread01()&#123; num++; &#125; @Override public void run() &#123; System.out.println(\"主动创建的第\"+num+\"个线程\"); &#125;&#125; 执行结果： 12345678910111213主动创建的第1个线程主动创建的第2个线程主动创建的第3个线程主动创建的第4个线程主动创建的第5个线程主动创建的第6个线程主动创建的第7个线程......主动创建的第99个线程主动创建的第100个线程Process finished with exit code 0 调用子线程的join()方法，可以让main线程等待子线程的执行，然后再继续执行子线程。 7.总结 线程的创建方式推荐实现Runnable接口 本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。 继承Thread类时，最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出现了问题。 参考：Java多线程学习（吐血超详细总结）Java核心技术—多线程（THREAD）Java并发编程，你需要知道的","tags":[{"name":"Java","slug":"Java","permalink":"http://successli.cn/tags/Java/"}]},{"title":"Java 形参与实参","date":"2017-09-29T16:00:00.000Z","path":"2017/09/30/Java-形参与实参/","text":"前几天在头条上看到一道经典面试题,引发了一些思考。也是写这篇文章的导火索。 背景请看题:12345678910111213public class Main &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; System.out.println(\"a=\" + a + \",b=\" + b); swap(a, b); System.out.println(\"a=\" + a + \",b=\" + b); &#125; private static void swap(Integer numa, Integer numb) &#123; //请实现 &#125;&#125; 看到这个题后 瞬间觉得有坑。也觉得为什么要书写一个swap方法呢？如下实现不是更简单:123456789public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; System.out.println(\"a=\" + a + \",b=\" + b); Integer tmp = a; a = b; b = tmp; System.out.println(\"a=\" + a + \",b=\" + b); &#125; 输出:12a=1,b=2a=2,b=1 完美实现交换。但是请注意，这是一道面试题，要的就是考验一些知识点。所以还是老老实实的实现swap方法吧。有的同学可能会想，Integer 是一个包装类型,是对Int的装箱和拆箱操作。其实也是一个对象。既然是对象，直接更改对象的引用不就行了？思路没问题，我们首先看看实现:123456private static void swap(Integer numa, Integer numb) &#123; Integer tmp = numa; numa = numb; numb = tmp; System.out.println(\"numa=\" + numa + \",numb=\" + numb);&#125; 输出:123a=1,b=2numa=2,numb=1a=1,b=2 不出意外,没有成功这是什么原因呢？技术老手一看就知道问题出在形参和实参混淆了 JAVA的形参和实参的区别:形参 顾名思义:就是形式参数，用于定义方法的时候使用的参数，是用来接收调用者传递的参数的。 形参只有在方法被调用的时候，虚拟机才会分配内存单元，在方法调用结束之后便会释放所分配的内存单元。 因此,形参只在方法内部有效，所以针对引用对象的改动也无法影响到方法外。 实参 顾名思义:就是实际参数，用于调用时传递给方法的参数。实参在传递给别的方法之前是要被预先赋值的。 在本例中 swap 方法 的numa, numb 就是形参，传递给 swap 方法的 a,b 就是实参 注意:在值传递调用过程中，只能把实参传递给形参，而不能把形参的值反向作用到实参上。在函数调用过程中，形参的值发生改变，而实参的值不会发生改变。而在引用传递调用的机制中，实际上是将实参引用的地址传递给了形参，所以任何发生在形参上的改变也会发生在实参变量上。那么问题来了，什么是值传递和引用传递 值传递和引用传递在谈值传递和引用传递之前先了解下 Java的数据类型有哪些 JAVA的数据类型Java 中的数据类型分为两大类，基本类型和对象类型。相应的，变量也有两种类型：基本类型和引用类型基本类型的变量保存原始值，即它代表的值就是数值本身,原始值一般对应在内存上的栈区而引用类型的变量保存引用值，引用值指向内存空间的地址。代表了某个对象的引用，而不是对象本身。对象本身存放在这个引用值所表示的地址的位置。被引用的对象对应内存上的堆内存区。基本类型包括：byte,short,int,long,char,float,double,boolean 这八大基本数据类型引用类型包括：类类型，接口类型和数组 变量的基本类型和引用类型的区别基本数据类型在声明时系统就给它分配空间123int a;//虽然没有赋值，但声明的时候虚拟机就会 分配 4字节 的内存区域,而引用数据类型不同，它声明时只给变量分配了引用空间，而不分配数据空间: String str;//声明的时候没有分配数据空间，只有 4byte 的引用大小，在栈区，而在堆内存区域没有任何分配str.length(); //这个操作就会报错，因为堆内存上还没有分配内存区域，而 a = 1; 这个操作就不会报错。 好了，Java的数据类型说完了，继续我们的值传递和引用传递的话题。先背住一个概念:基本类型的变量是值传递；引用类型的变量结合前面说的 形参和实参。 值传递方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值 引用传递也称为地址传递，址传递。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象通过例子来说话:123456789101112131415161718192021222324static class Person &#123; int age; Person(int age) &#123; this.age = age; &#125; &#125; private static void test() &#123; int a = 100; testValueT(a); System.out.println(\"a=\" + a); Person person = new Person(20); testReference(person); System.out.println(\"person.age=\" + person.age); &#125; private static void testValueT(int a) &#123; a = 200; System.out.println(\"int testValueT a=\" + a); &#125; private static void testReference(Person person) &#123; person.age = 10; &#125; 输出：123int testValueT a=200a=100person.age=10 看见 值传递 a的值并没有改变，而 引用传递的 persion.age已经改变了有人说123private static void testReference(Person person) &#123; person = new Person(100);&#125; 为什么 输出的 person.age 还是20呢？我想说 了解一下什么是引用类型吧？ 方法内把 形参的地址引用换成了另一个对象，并没有改变这个对象,并不能影响 外边实参还引用原来的对象，因为 形参只在方法内有效哦。 有人或许还有疑问，按照文章开头的例子，Integer也是 引用类型该当如何呢？其实 类似的 String,Integer,Float,Double,Short,Byte,Long,Character等等基本包装类型类。因为他们本身没有提供方法去改变内部的值，例如Integer 内部有一个value 来记录int基本类型的值，但是没有提供修改它的方法，而且 也是final类型的，无法通过常规手段更改。所以虽然他们是引用类型的，但是我们可以认为它是值传递,这个也只是认为,事实上还是引用传递,址传递。 好了，基础知识补充完毕，然我们回到面试题吧 回归正题 123456private static void swap(Integer numa, Integer numb) &#123; Integer tmp = numa; numa = numb; numb = tmp; System.out.println(\"numa=\" + numa + \",numb=\" + numb); &#125; 通过补习基础知识，我们很明显知道 上面这个方法实现替换 是不可行的。因为Interger虽然是引用类型但是上述操作只是改变了形参的引用，而没有改变实参对应的对象。 那么思路来了，我们通过特殊手段改变 Integer内部的value属性1234567891011private static void swap(Integer numa, Integer numb) &#123; Integer tmp = numa; try &#123; Field field = Integer.class.getDeclaredField(\"value\"); field.setAccessible(true); field.set(numa, numb);//成功的将numa 引用的 1的对象 值改为 2 field.set(numb, tmp); //由于 tmp 也是指向 numa 未改变前指向的堆 即对象1 ，经过前一步，已经将对象1的值改为了2，自然 numb 也是2，所以改动失效 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 输出结果: 12a=1,b=2a=2,b=2 又来疑问了？为何 a的值改变成功，而b的改变失败呢？ 见代码注释所以其实 field.set(numb, tmp); 是更改成功的，只是 tmp 经过前一行代码的执行，已经变成了 2。那么如何破呢？我们有了一个思路，既然是 tmp的引用的对象值变量，那么我让tmp不引用 numa了1234567891011private static void swap(Integer numa, Integer numb) &#123; int tmp = numa.intValue();//tmp 定义为基本数据类型 try &#123; Field field = Integer.class.getDeclaredField(\"value\"); field.setAccessible(true); field.set(numa, numb);//这个时候并不改变 tmp 的值 field.set(numb, tmp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 这种情况下 对 numa 这个对象的修改就不会导致 tmp 的值变化了,看一下运行结果 a=1,b=2 a=2,b=2 这是为啥？有没有快疯啦？难道我们的思路错了？先别着急，我们看看这个例子：仅仅是将前面的例子 a的值改为 129，b的值改为130 1234567891011121314151617181920public static void main(String[] args) &#123; Integer a = 129; Integer b = 130; System.out.println(\"a=\" + a + \",b=\" + b); swap(a, b); System.out.println(\"a=\" + a + \",b=\" + b); &#125; private static void swap(Integer numa, Integer numb) &#123; int tmp = numa.intValue(); try &#123; Field field = Integer.class.getDeclaredField(\"value\"); field.setAccessible(true); field.set(numa, numb); field.set(numb, tmp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 运行结果:12a=129,b=130a=130,b=129 有没有怀疑人生？我们的思路没有问题啊?为什么 换个数值就行了呢？我们稍微修改一下程序1234567891011121314151617181920public static void main(String[] args) &#123; Integer a = new Integer(1); Integer b = new Integer(2); System.out.println(\"a=\" + a + \",b=\" + b); swap(a, b); System.out.println(\"a=\" + a + \",b=\" + b); &#125; private static void swap(Integer numa, Integer numb) &#123; int tmp = numa.intValue(); try &#123; Field field = Integer.class.getDeclaredField(\"value\"); field.setAccessible(true); field.set(numa, numb); field.set(numb, tmp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 运行结果:12a=1,b=2a=2,b=1 哎？为啥 1 和 2 也可以了?我们这时肯定猜想和Integer的装箱 拆箱有关 装箱，拆箱 概念Integer的装箱操作为什么 Integer a = 1 和 Integer a = new Integer(1) 效果不一样那就瞅瞅源码吧？ 123456789101112131415161718192021222324public Integer(int value) &#123; this.value = value;&#125;/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 通过注释知道，java推荐 Integer.valueOf 方式初始化一个Interger因为有 缓存了-128 - 127的数字我们直接定义 Integer a = 1 具有这个功能，所以 Jvm 底层实现 是通过 Integer.valueOf这个方法再看 field.set(numb, tmp);我们打断点，发现通过反射设置 value时 竟然走了 Integer.valueOf 方法下面是 我们调用 swap前后的 IntegerCache.cache 值得变化 反射修改前: 反射修改后在反射修改前 123IntegerCache.cache[128]=0IntegerCache.cache[129]=1IntegerCache.cache[130]=2 通过反射修改后 123IntegerCache.cache[128]=0IntegerCache.cache[129]=2IntegerCache.cache[130]=2 再调用 field.set(numb, tmp) tmp这时等于1 对应的 角标 129 ,但是这个值已经变成了2所以出现了刚才 奇怪的结果原来都是缓存的锅下面趁机再看个例子 加深理解 123456Integer testA = 1;Integer testB = 1;Integer testC = 128;Integer testD = 128;System.out.println(\"testA=testB \" + (testA == testB) + \",\\ntestC=testD \" + (testC == testD)); 输出结果: 12testA=testB true,testC=testD false 通过这小示例，在 -128 到 127的数字都走了缓存，这样 testA 和 testB引用的是同一片内存区域的同一个对象。而 testC testD 数值大于127 所以 没有走缓存，相当于两个Integer对象，在堆内存区域有两个对象。两个对象自如不相等。在前面的示例中 我们 通过12Integer a = new Integer(1);Integer b = new Integer(2); 方式初始化 a,b 我们的交换算法没有问题，也是这个原因。 那么到目前为止我们的swap 方法可以完善啦1234567891011private static void swap(Integer numa, Integer numb) &#123; int tmp = numa.intValue(); try &#123; Field field = Integer.class.getDeclaredField(\"value\"); field.setAccessible(true); field.set(numa, numb); field.set(numb, new Integer(tmp)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 只需将之前的 field.set(numb, tmp) 改为 field.set(numb, new Integer(tmp)) 到此, 这个面试我们已经通过了，还有一个疑问我没有解答。为什么 field.set(numb, tmp) 会执行 Integer.valueOf() 而 field.set(numb, new Integer(tmp)) 不会执行。这就是Integer的装箱操作，当 给 Integer.value 赋值 int时，JVM 检测到 int不是Integer类型,需要装箱，才执行了Integer.valueOf()方法。而field.set(numb, new Integer(tmp)) 设置的 是Integer类型了，就不会再拆箱后再装箱。 Over Thanks 注：（转载）DailyCast博客-Java形参与实参","tags":[{"name":"Java","slug":"Java","permalink":"http://successli.cn/tags/Java/"}]},{"title":"搭建successli个人技术博客","date":"2017-07-19T16:00:00.000Z","path":"2017/07/20/搭建successli个人技术博客/","text":"successli技术博客搭建采用Hexo，一款快速、简洁且高效的博客框架。下面是具体的搭建和更新博客的步骤。 环境准备 根据 官网文档 安装NodeJS和Git。 安装NodeJS完成以后，使用npm安装hexo-cli博客管理工具，如果网络不好这个过程通常很慢。 1$ npm install -g hexo-cli 创建博客如果你是博客的发布人员，直接查看发布文章段落。 创建Github仓库successli.github.io 初始化博客系统 1hexo init successli.github.io 进入博客目录，并初始化博客。 12cd successli.github.io/npm install 修改博客基本信息在_config.yml里面修改标题和描述 配置博客插件。当前项目目录安装发布工具， 1npm install hexo-deployer-git --save 同时安装启动服务插件，以便本地可以启动 1npm install hexo-server --save 然后在_config.yml里面配置如下内容： 1234deploy: type: git repo: https://github.com/successli/successli.github.io branch: master 关联Github仓库，并把源码推送到远程，因为master是留给生成文件的，所以发布到了非master分支。 123456git initgit remote add origin https://github.com/successli/successli.github.io.gitgit checkout -b sourcegit add .git commit -m \"init blog\"git push -u origin source 发布博客直接运行如下命令发布博客，该命令会自动发布内容到master分支 1hexo deploy 发布文章 如果本地没有仓库请clone仓库，并且切换到source分支。 12git clone https://github.com/successli/successli.github.io.gitgit branch source Setup本地环境在项目目录运行如下命令安装依赖和初始化环境。 1npm install 运行如下命令创建博客文章，后面的参数便是文章的标题 1hexo new '搭建successli个人技术博客' 在source/_posts目录找到刚才对应的文章，进入编辑文档即可。编辑过程中可以使用如下命令启动服务器和实时预览效果。 12hexo serverhexo generate --watch 发布源码编辑文章完成以后运行如下命令发布源码到Github仓库 123git add .git commit -m &quot;add new post&quot;git push origin source 发布文章 1hexo generate --deploy 参考： 搭建DailyCast技术博客","tags":[{"name":"hexo","slug":"hexo","permalink":"http://successli.cn/tags/hexo/"}]},{"title":"基于Maven构建SSM框架教程","date":"2016-08-19T16:00:00.000Z","path":"2016/08/20/基于Maven构建SSM框架/","text":"1.建立数据库表123456CREATE TABLE `t_blogger` ( id int(11) NOT NULL AUTO_INCREMENT, username varchar(50) DEFAULT NULL, password varchar(100) DEFAULT NULL, PRIMARY KEY (`id`)) DEFAULT CHARSET=utf8; 2.Maven方式搭建Spring+SpringMVC+Mybatis环境 pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加连接池druid支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis-spring支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-dao --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-dao&lt;/artifactId&gt; &lt;version&gt;2.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jdbc驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; ​ Spring配置文件applicationContext.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 启用spring-mvc注解--&gt; &lt;context:annotation-config/&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/db_springdemo\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/bean&gt; &lt;!-- 配置mybatis的sqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!-- 自动扫描mappers.xml文件 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:cn.successli.mapper/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"cn.successli.dao\" /&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=\"cn.successli.service\" /&gt;&lt;/beans&gt; spring-mvc.xml1234567891011&lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 使用注解的包，包括子集 --&gt; &lt;context:component-scan base-package=\"cn.successli.controller\" /&gt; ​ web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"&gt; &lt;display-name&gt;aa&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;a.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置web.xml，使其具有springmvc特性，主要配置两处，一个是ContextLoaderListener，一个是DispatcherServlet --&gt; &lt;!-- spring mvc 配置 --&gt; &lt;!-- 1.配置DispatcherServlet表示，该工程将采用springmvc的方式。 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;webmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 启动项目的时候要加载的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;webmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 2.spring配置 :配置ContextLoaderListener表示，该工程要以spring的方式启动.启动时会默认在/WEB-INF目录下查找applicationContext.xml作为spring容器的配置文件，该文件里可以初始化一些bean--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 指定Spring Bean的配置文件所在目录。默认配置在WEB-INF目录下 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 字符集过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 以上，Spring+SpringMVC+Mybatis的开发环境基本搭建好。 建立实体类，完成对数据库的操作。 3.建立实体类及Mapper对象 实体类User 1234567891011121314151617181920212223242526272829303132333435package cn.successli.entity;/** * Created by liyon on 2017/5/30. */public class User &#123; private Integer id; private String username;//用户名 private String password;//密码 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 建立DAO层及Mapper对象 UserDAO.java 123456789101112131415161718192021222324252627282930313233343536373839package cn.successli.dao;import cn.successli.entity.User;import org.springframework.stereotype.Component;/** * Created by liyon on 2017/5/30. */public interface UserDAO &#123; /** * 增加一个用户 * @param user * @return */ public Integer add(User user); /** * 删除一个用户 * @param user * @return */ public Integer delete(User user); /** * 修改某个用户信息 * @param user * @return */ public Integer modify(User user); /** * 通过用户名查找用户信息 * @param username * @return */ public User findUserByName(String username);&#125; UserMapper.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.successli.dao.UserDAO\"&gt; &lt;resultMap id=\"UserResult\" type=\"cn.successli.entity.User\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"password\" column=\"password\"/&gt; &lt;/resultMap&gt; &lt;insert id=\"add\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; INSERT INTO t_blogger (username, password) VALUES (#&#123;username&#125;,#&#123;password&#125;); &lt;/insert&gt; &lt;delete id=\"delete\"&gt; DELETE FROM t_blogger WHERE id = #&#123;id&#125;; &lt;/delete&gt; &lt;update id=\"modify\"&gt; UPDATE t_blogger SET username = #&#123;username&#125;, password = #&#123;password&#125; WHERE id = #&#123;id&#125;; &lt;/update&gt; &lt;select id=\"findUserByName\" resultMap=\"UserResult\"&gt; SELECT * FROM t_blogger WHERE username = #&#123;username&#125;; &lt;/select&gt; &lt;/mapper&gt; ​ 4.编写测试代码 测试代码需要引用的包 12345678910111213&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 测试类基本配置 12@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\") ​ 测试类的编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.successli.dao;import cn.successli.entity.User;import junit.framework.Assert;import junit.framework.TestCase;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;import static org.junit.Assert.*;/** * Created by liyon on 2017/5/30. */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class UserDAOTest extends AbstractJUnit4SpringContextTests &#123; @Resource private UserDAO userDAO; @Test public void testAdd() throws Exception &#123; User user = new User(); user.setUsername(\"hou\"); user.setPassword(\"123456\"); int result = userDAO.add(user); org.junit.Assert.assertEquals(1, result); &#125; @Test public void testDelete() throws Exception &#123; User user = userDAO.findUserByName(\"hou\"); int result = userDAO.delete(user); org.junit.Assert.assertEquals(1, result); &#125; @Test public void testModify() throws Exception &#123; User user = userDAO.findUserByName(\"hou\"); user.setUsername(\"houyr\"); user.setPassword(\"123\"); int result = userDAO.modify(user); org.junit.Assert.assertEquals(1, result); &#125; @Test public void testFindUserByName() throws Exception &#123; User user = userDAO.findUserByName(\"hou\"); org.junit.Assert.assertNotNull(user); &#125;&#125; 测试成功，完成Demo。","tags":[{"name":"Java,Maven,IDEA,SSM","slug":"Java-Maven-IDEA-SSM","permalink":"http://successli.cn/tags/Java-Maven-IDEA-SSM/"}]},{"title":"JDBC连接数据库笔记","date":"2016-06-09T16:00:00.000Z","path":"2016/06/10/JDBC连接数据库笔记/","text":"准备工作 新建一个Java工程 新建一个数据库warehouse 新建表mylist 向表中添加数据 +—–+————-+| id | name |+—–+————-+| 111 | liyongsheng || 222 | zhangsan || 333 | xiaoming |+—–+————-+ 1.加载JDBC驱动程序 通过 java.lang.Class类的静态方法forName(String className)实现 1234567try &#123; //加载mysql的驱动类 Class.forName(\"com.mysql.jdbc.Driver\");&#125; catch(ClassNotFoundException e) &#123; System.Out.Println(\"驱动程序加载失败\"); e.printStackTrace();&#125; 成功加载mysql的驱动类后会将Driver类的实例注册到DriverManager类中 2.提供JDBC连接的URL 连接URL定义了连接数据库时的协议、子协议、数据库标识 协议：在JDBC中总是以jdbc开头子协议：是桥接的程序或者数据库管理系统的名称数据库标识：标记找到数据库来源的地址和连接端口 1String url = \"jdbc:mysql://localhost:3306/warehouse?useUnicode=true&amp;characterEncoding=gbk\"; 3.创建数据库的连接 要连接数据库，需要向java.lang.DriverManager请求并获得一个Connection对象，该对象就代表一个数据库连接 使用方法如下 1DriverManager.getConnect(String url, String username, String password); 4.创建一个Statement对象 要执行SQL语句，必须获得java.sql.Statement的实例Statement的实例分为三种类型： 123456//执行静态SQL语句Statement stmt=connection.createStatement();//执行动态SQL语句PreparedStatement pstmt = con.prepareStatement(sql);//执行数据库存储过程CallableStatement cstmt = con.prepareCall(\"&#123;CALL demoSp(? , ?)&#125;\"); 5.执行SQL语句Statement提供三种方法： 123456//1.执行查询数据库的SQL语句，返回一个结果集（ResultSet）对象。ResultSet rs = stmt.executeQuery(\"SELECT * FROM ...\");//2.用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句int rows = stmt.executeUpdate(\"INSERT INTO ...\");//3.用于执行返回多个结果集、多个更新计数或二者组合的语句boolean flag = stmt.execute(String sql); 6.处理结果两种情况: 执行更新返回的是本次操作影响到的记录数。 执行查询返回的结果是一个ResultSet对象。 1234while(rs.next())&#123; String name = rs.getString(\"name\") ; String pass = rs.getString(1) ; // 此方法比较高效&#125; 7.关闭JDBC对象 关闭顺序和声明顺序相反 关闭resultSet结果集 关闭statement声明 关闭connection连接 123456789101112131415161718192021if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;if (statement != null) &#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 附源程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.successli.jdbcTest;import java.sql.*;/** * Created by liyon on 2016.6.1. */public class mysqlConnection &#123; public static void main(String[] args) &#123; Connection connection; Statement statement; ResultSet resultSet; //1.加载jdbc驱动程序 try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; System.out.println(\"找不到驱动程序，加载驱动失败\"); e.printStackTrace(); &#125; //2.提供JDBC连接的URL //String url = \"jdbc:mysql://localhost:3306/warehouse\"; String url = \"jdbc:mysql://localhost:3306/warehouse?useUnicode=true&amp;characterEncoding=gbk\"; String username = \"root\"; String password = \"1234\"; try &#123; //3.建立连接 connection = DriverManager.getConnection(url,username,password); //4.创建一个statement声明 statement = connection.createStatement(); //5.执行SQL语句，返回结果集resultSet resultSet = statement.executeQuery(\"select * from mylist;\"); //6.处理返回结果集resultSet的结果 while (resultSet.next()) &#123; int id = resultSet.getInt(1); String name = resultSet.getString(2); System.out.println(id); System.out.println(name); &#125; //7.关闭连接 if (resultSet != null) &#123; try &#123; resultSet.close(); System.out.println(\"resultSet已关闭\"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (statement != null) &#123; try &#123; statement.close(); System.out.println(\"statement已关闭\"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); System.out.println(\"connection已关闭\"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (SQLException se) &#123; System.out.println(\"数据库连接失败\"); se.printStackTrace(); &#125; &#125;&#125; 执行结果： 123456789111liyongsheng222zhangsan333xiaomingresultSet已关闭statement已关闭connection已关闭","tags":[{"name":"Java","slug":"Java","permalink":"http://successli.cn/tags/Java/"}]},{"title":"Git学习笔记","date":"2016-05-09T16:00:00.000Z","path":"2016/05/10/Git学习笔记/","text":"将某个文件夹设置为git仓库：在这个文件夹下打开命令行 1git init 添加文件到git本地仓库第一步 123git add file1git add file2git add file3 一般使用 1git add . 第二步 git命令行commit不支持中文提示 1git commit -m &quot;add 3 files&quot; 时光穿梭查看仓库状态 1git status 查看文件修改了哪些内容 1git diff file1 版本回退 创建与合并分支查看分支1git branch 创建分支1git branch name 切换分支1git checkout name 创建并切换分支1git checkout -b name 合并某分支到当前分支1git merge name 删除分支1git checkout -d name 多人协作• 查看远程库信息，使⽤1git remote -v • 本地新建的分⽀如果不推送到远程，对其他⼈就是不可⻅的；• 从本地推送分⽀，使⽤1git push origin branch-name ，如果推送失败，先⽤git pull抓取远程的新提交；• 在本地创建和远程分⽀对应的分⽀,使用1git checkout -b branch-name origin/branchname ，本地和远程分⽀的名称最好⼀致；• 建⽴本地分⽀和远程分⽀的关联，使⽤1git branch --set-upstream branch-name origin/branch-name • 从远程抓取分⽀，使⽤git pull，如果有冲突，要先处理冲突。","tags":[{"name":"Git","slug":"Git","permalink":"http://successli.cn/tags/Git/"}]},{"title":"读《第一行代码》有感","date":"2016-04-30T16:00:00.000Z","path":"2016/05/01/读《第一行代码》有感/","text":"一个活动新建一个android工程，默认不创建活动，新建FirstActivity.java文件 1.加载布局文件12345678@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); //加载布局文件 setContentView(R.layout.first_layout);&#125; 2.注册Activity在AndroidManifest.xml文件中 12345678910111213141516&lt;application android:allowBackup=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\" &gt; &lt;-&lt;!-- 注册活动 --&gt; &lt;activity android:name=\".FirstActivity\" android:label=\"This is first activity\"&gt; &lt;intent-filter&gt; &lt;!-- 定义为主活动 --&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 3.隐藏标题栏123456789 @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); //隐藏标题栏 requestWindowFeature(Window.FEATURE_NO_TITLE); //加载布局文件 setContentView(R.layout.first_layout); &#125; 4.在活动中使用Toast12345Toast.makeText(this, \"Clicked Add\", Toast.LENGTH_SHORT).show();//第一个参数是活动的上下文//第二个参数是显示的文本//第三个参数是 示的时间长短（Toast.LENGTH_SHORT or Toast.LENGTH_LONG）Toast android.widget.Toast.makeText(Context context, CharSequence text, int duration); 5.在活动中使用Menu 在res-&gt;menu下新建一个Menu Resource Type 的**.xml文件 编辑**.xml文件 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;item android:id=\"@+id/add_item\" android:title=\"Add\" /&gt; &lt;item android:id=\"@+id/remove_item\" android:title=\"Remove\" /&gt;&lt;/menu&gt; 重写FirstActivity.java中onCreateOptionsMenu()方法12345678@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; // TODO Auto-generated method stub getMenuInflater().inflate(R.menu.**, menu); return true;&#125; 为了使Menu中的item能够有功能，重写onOptionsItemSelected()方法 12345678910111213141516@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; // TODO Auto-generated method stub switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this, \"Clicked Add\", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, \"Clicked Remove\", Toast.LENGTH_SHORT).show(); break; default: break; &#125; return true;&#125; 6.销毁一个活动Activity类提供了一个方法,来销毁一个活动 1234567//finish(); @Override public void onClick(View v) &#123; // TODO Auto-generated method stub// Toast.makeText(FirstActivity.this, &quot;clicked&quot;, Toast.LENGTH_SHORT).show(); finish();//销毁活动 &#125; 以上是创建一个活动涉及的知识 活动之间1.使用显式Intent12345678910 @Override public void onClick(View v) &#123; // TODO Auto-generated method stub// Toast.makeText(FirstActivity.this, &quot;clicked&quot;, Toast.LENGTH_SHORT).show();// finish();//销毁活动//使用显式Intent在FirstActivity活动基础上打开SecondActivity活动 Intent intent = new Intent(FirstActivity.this, SecondActivity.class);//调用startActivity()执行intent startActivity(intent); &#125; 2.使用隐式Intent需要实现从FirstActivity到达另外一个符合要求的活动中去SecondActivity需要符合这个要求首先在ActivityManifest.xml文件中定义和标签 12345678&lt;activity android:name=&quot;.SecondActivity&quot; &gt; &lt;intent-filter&gt; &lt;!-- 定义一个标签来符合要求被FirstActivity活动启动 --&gt; &lt;action android:name=&quot;***&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 然后在FirstActivity中的onClick()方法中setAction这个标签，达到启动指定要求的应用的目的有两种方法设置这个category1.在构造方法中setAction这个category这个标签2.直接调用Intent对象的intent.setAction()方法设置标签 12345678910111213 @Override public void onClick(View v) &#123; // TODO Auto-generated method stub// Toast.makeText(FirstActivity.this, &quot;clicked&quot;, Toast.LENGTH_SHORT).show();// finish();//销毁活动// Intent intent = new Intent(FirstActivity.this, SecondActivity.class);// startActivity(intent); //隐式Intent Intent intent=new Intent(&quot;***&quot;);//构造方法// Intent intent=new Intent();// intent.setAction(&quot;com.example.activity.ACTION_START&quot;) startActivity(intent); &#125; 因为startActivity启动时就是根据默认的category标签，所以 1&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; 可以调用默认的category来startActivity，当然我们也可以设置 12Intent intent=new Intent();intent.setCategory(&quot;***&quot;); 3.更多隐式Intent用法123Intent intent=new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;));startActivity(intent); 指定Intent的action是Intent.ACTION_VIEW,是安卓系统内置动作，其常量为 1android.intent.action.VIEW Uri.parse(&quot;http://www.baidu.com&quot;) 将网址解析成一个Uri对象 调用Intent的 setData() 方法将Uri对象传递进去","tags":[{"name":"Java,Android","slug":"Java-Android","permalink":"http://successli.cn/tags/Java-Android/"}]}]